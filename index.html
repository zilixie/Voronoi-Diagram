<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<link type="text/css" rel="stylesheet" href="css/github-markdown.css"/>
<link rel="stylesheet" href="css/github-markdown.css">
<style>
.markdown-body {
box-sizing: border-box;
min-width: 200px;
max-width: 980px;
margin: 0 auto;
padding: 45px;
}
</head>
<body>

<pre><code>@media (max-width: 767px) {
    .markdown-body {
        padding: 15px;
    }
}
</code></pre>

<p></style>
<article class="markdown-body"></p>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "all"} } });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<div style="display:none">
<span class="math">\(\newcommand{\A}{\mat{A}}\)</span>
<span class="math">\(\newcommand{\B}{\mat{B}}\)</span>
<span class="math">\(\newcommand{\C}{\mat{C}}\)</span>
<span class="math">\(\newcommand{\D}{\mat{D}}\)</span>
<span class="math">\(\newcommand{\E}{\mat{E}}\)</span>
<span class="math">\(\newcommand{\F}{\mat{F}}\)</span>
<span class="math">\(\newcommand{\G}{\mat{G}}\)</span>
<span class="math">\(\newcommand{\H}{\mat{H}}\)</span>
<span class="math">\(\newcommand{\I}{\mat{I}}\)</span>
<span class="math">\(\newcommand{\J}{\mat{J}}\)</span>
<span class="math">\(\newcommand{\K}{\mat{K}}\)</span>
<span class="math">\(\newcommand{\L}{\mat{L}}\)</span>
<span class="math">\(\newcommand{\M}{\mat{M}}\)</span>
<span class="math">\(\newcommand{\N}{\mat{N}}\)</span>
<span class="math">\(\newcommand{\One}{\mathbf{1}}\)</span>
<span class="math">\(\newcommand{\P}{\mat{P}}\)</span>
<span class="math">\(\newcommand{\Q}{\mat{Q}}\)</span>
<span class="math">\(\newcommand{\Rot}{\mat{R}}\)</span>
<span class="math">\(\newcommand{\R}{\mathbb{R}}\)</span>
<span class="math">\(\newcommand{\S}{\mathcal{S}}\)</span>
<span class="math">\(\newcommand{\T}{\mat{T}}\)</span>
<span class="math">\(\newcommand{\U}{\mat{U}}\)</span>
<span class="math">\(\newcommand{\V}{\mat{V}}\)</span>
<span class="math">\(\newcommand{\W}{\mat{W}}\)</span>
<span class="math">\(\newcommand{\X}{\mat{X}}\)</span>
<span class="math">\(\newcommand{\Y}{\mat{Y}}\)</span>
<span class="math">\(\newcommand{\argmax}{\mathop{\text{argmax}}}\)</span>
<span class="math">\(\newcommand{\argmin}{\mathop{\text{argmin}}}\)</span>
<span class="math">\(\newcommand{\a}{\vec{a}}\)</span>
<span class="math">\(\newcommand{\b}{\vec{b}}\)</span>
<span class="math">\(\newcommand{\c}{\vec{c}}\)</span>
<span class="math">\(\newcommand{\d}{\vec{d}}\)</span>
<span class="math">\(\newcommand{\e}{\vec{e}}\)</span>
<span class="math">\(\newcommand{\f}{\vec{f}}\)</span>
<span class="math">\(\newcommand{\g}{\vec{g}}\)</span>
<span class="math">\(\newcommand{\mat}[1]{\mathbf{#1}}\)</span>
<span class="math">\(\newcommand{\min}{\mathop{\text{min}}}\)</span>
<span class="math">\(\newcommand{\m}{\vec{m}}\)</span>
<span class="math">\(\newcommand{\n}{\vec{n}}\)</span>
<span class="math">\(\newcommand{\p}{\vec{p}}\)</span>
<span class="math">\(\newcommand{\q}{\vec{q}}\)</span>
<span class="math">\(\newcommand{\r}{\vec{r}}\)</span>
<span class="math">\(\newcommand{\transpose}{{\mathsf T}}\)</span>
<span class="math">\(\newcommand{\tr}[1]{\mathop{\text{tr}}{\left(#1\right)}}\)</span>
<span class="math">\(\newcommand{\s}{\vec{s}}\)</span>
<span class="math">\(\newcommand{\t}{\vec{t}}\)</span>
<span class="math">\(\newcommand{\u}{\vec{u}}\)</span>
<span class="math">\(\newcommand{\vec}[1]{\mathbf{#1}}\)</span>
<span class="math">\(\newcommand{\x}{\vec{x}}\)</span>
<span class="math">\(\newcommand{\y}{\vec{y}}\)</span>
<span class="math">\(\newcommand{\z}{\vec{z}}\)</span>
<span class="math">\(\newcommand{\0}{\vec{0}}\)</span>
<span class="math">\(\renewcommand{\v}{\vec{v}}\)</span>
<!-- https://github.com/mathjax/MathJax/issues/1766 -->
<span class="math">\(\renewcommand{\hat}[1]{\widehat{#1}}\)</span>
</div>

<h1 id="computergraphicsâ€“raytracing">Visualization of the Fortune's Algorithm</h1>
<p>A line sweeping algorithm for constructing Voronoi Diagram implemented in C++ combined with OpenGL. Visualizations are created for better understanding of how the algorithm works. My visualization includes:
<ul style="margin-bottom: 16px;">
<li>Visualization of the Tree structure used for presenting Beachline</li>
<li>Visualization of the parabolas & beachline.</li>
<li>Visualization of the circle formed by circle events.</li>
</ul>
Some other events are presented with the help of plain text.
</p>

<h2 id="ds">How To Use</h2>
<p><code>Trackpad</code>: Use your trackpad to scroll the sweepline up/down to see the events at different time steps..<br>
<code>Q</code>: Quit the program.</p>

<h2 id="pl">Platform/Programming Language</h2>
<ul style="margin-bottom: 16px;">
<li>GLFW/C++</li>
<li>nanogui</li>
</ul>

<h2 id="ds">Data Structures</h2>
<p>This section introduces the main data structures that I defined for the general use in this project. The following classes are defined in <code>Voronoi.h</code> and <code>AVL.h</code> file.</p>

<h3>Event</h3>
<p> A Event can be either a site event or a circle event. A site event happens when the sweepline reaches a new site that has not yet been reached. A circle happens when the sweepline touch the bottom of the circle where the three associated points lie on. The Event class has a attribute named <code>position</code> that shows where the event actually happens and a integer vector called <code>associate</code> that stores the related points that are associated with this event. For circle event, there are 3 points, and for site event, there is only one.</p>
<pre><code style="color:#808080;">class Event {
	public:
		Eigen::Vector2d position;
		std::vector<int> associate;
		int type;

		Event(Eigen::Vector2d p, int s) {
			position = p;
			associate.push_back(s);
			type = 1;
		}
		Event(Eigen::Vector2d p, int s1, int s2, int s3) {
			position = p;
			associate.push_back(s1);
			associate.push_back(s2);
			associate.push_back(s3);
			type = 0;
		}
};</code></pre>


<h3>Voronoi</h3>
<p> The Voronoi class is the class that stores all the principle elements of the Voronoi diagram:
<ul style="margin-bottom: 16px;">
<li>Eigen Matrices of double to store the generated input points <code>points</code>. </li>
<li>Eigen Matrices of double to store the computed Voronoi vertices <code>vor_vtx</code>.</li>
<li>a Vector of 2x2 Matrix that collects each voronoi edges as a matrix <code>edges</code>.</li>
<li>a vector of 3 dimensional vector that collects the parameters for all parabolas <code>lines_param</code>.  </li>
<li>a vector of 1000x3 dimensional matrix to store the point on all parabolas <code>lines</code>.</li>
<li>a priority queue for all Events <code>event_queue</code>.</li>
</ul>
</p>
<pre><code style="color:#808080;">class Voronoi {
	public:
		double sweepline_y;
		int sub_div;

		// for visualize
		Eigen::MatrixXd points; //sites
		Eigen::MatrixXd vor_vtx; //sites

		std::vector &ltstd::vector &ltEigen::Vector2d &gt&gt vor_vtx_map; //table
		std::vector &ltEigen::Matrix2d> edges;
		std::vector &ltstd::vector &ltEigen::Vector3d &gt&gt open_edges;

		std::vector &lt Eigen::Vector3d> lines_param; //Parameters
		std::vector &lt Eigen::MatrixXd> lines; //sampled points on line
		Eigen::MatrixXd beach_line;
		Eigen::MatrixXd data;

		// for compute
		std::priority_queue &lt Event, std::vector &lt Event &gt, PQ_comparator> event_queue;

		Voronoi(int n);
		Eigen::Vector2d generate_point();
		Eigen::MatrixXd interpolate_line(double start, double end, double a, double b, double c);
		void update_lines_param();
		void update_lines_points();
		void update_data(double yoffset, Eigen::MatrixXd tree_edges);

		void extend_open_edges();
};</code></pre>

<h3>Node</h3>
<p> This class represents the nodes of the AVL tree used for beachline. Each node contains a height and a two dimensional integer vector <code>break_point</code> as attributes. The break point <code>[0,1]</code> stand for the intersection between the parabola number 0 and the parabola number 1, where 0 is to the left of the intersection and 1 is to the right. A node also has a pointer to its left and a pointer to its right child.   </p>
<pre><code style="color:#808080;">class node{
	public:
		int height;
		Eigen::Vector2i break_point;
		node* left;
		node* right;

		node (Eigen::Vector2i bp) {
			height = 1;
			break_point = bp;
			left = NULL;
			right = NULL;
		}
};</code></pre>


<h3>AVL</h3>
<p> The last one will be the class of AVL tree. An AVL tree is initialized with the entire voronoi diagram, so that the graph data can be accessed within the class. When making query within the tree, the key value of each node are determined by computing the corresponding intersection, which requires access to the points data and current sweepline location.</p>
<pre><code style="color:#808080;">class AVL{
	public:
		node* root = NULL;
		Eigen::MatrixXd points;
		double sweepline_y;
		std::vector<Eigen::Vector3i> tree_rep;
		std::vector<std::string> msg;

		AVL(Voronoi* diagram) {
			points = diagram->points;
			Eigen::Vector3d new_point = points.row(1);
			sweepline_y = new_point(1);
			Eigen::Vector3d arc_params = get_line_params(0);
			double pa = arc_params(0);
			double pb = arc_params(1);
			double pc = arc_params(2);
			double intersect_y = pa*new_point(0)*new_point(0) + pb*new_point(0) + pc;
			diagram->open_edges[0][1] = Eigen::Vector3d(new_point(0), intersect_y, 1);
			diagram->open_edges[1][0] = Eigen::Vector3d(new_point(0), intersect_y, 1);
		}
		...
};</code></pre>

<h2 id="ds">Example</h2>
<p> Before any event happens. The first event to meet is the site event of site 1.</p>
<img src="images/2.png">
<p> Next, our sweepline hits site 1. The new parabola will intersect with parabola 0 in all cases.</p>
<img src="images/3.png">
<p> We hit site 2. The arc that is vertically above the new parabola is parabola 0. node (0, 2) and (2, 0) are being inserted to our AVL tree as two new break points are created by this site event. We also need to check if the new site forms new circle events with its neighbours. In this case, circle event (2, 0, 1) are found and will be inserted to our priority queue.</p>
<img src="images/4.png">
<p> We insert site 3. Again, two new nodes (0, 3) and (3, 0) will be inserted to our AVL tree. This time the new site is not to the left of all other sites, so two new circle events (2, 0, 3) and (3, 0, 1) will be added to the queue. After the site being inserted, we will be hitting a circle event (3, 0, 1) next. </p>
<img src="images/5.png">
<p> The circel event (3, 0, 1) is hitted and a new Voronoi vertex is added. This will remove the nodes (3, 0) and (0, 1) and replace with a new node (3, 1).</p>
<img src="images/6.png">
<p> Insert site 4.</p>
<img src="images/7.png">
<p> Insert site 5.</p>
<img src="images/8.png">


<h2 id="ds">How To Run?</h2>
<blockquote>
<pre><code>cd voronoi
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release ../
make
./nanogui_test</code></pre>
</blockquote>


</body>
</html>
